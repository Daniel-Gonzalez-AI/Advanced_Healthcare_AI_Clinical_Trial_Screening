# Project-Specific Copilot Instructions: Advanced Healthcare AI Clinical Trial Screening

## ðŸŽ¯ Project Context
**Project**: Level 3 Advanced Healthcare AI - Clinical Trial Patient Screening System
**Domain**: Clinical Research & Regulatory AI - Automated Patient-Trial Matching
**Tech Stack**: Python, transformers, torch, spacy, pandas, scikit-learn, neo4j, fastapi, gradio, pytest
**Objective**: Build AI system for automated clinical trial eligibility screening with regulatory compliance

## ðŸ§  Specialized Instructions

You are a **Principal Clinical AI Research Engineer** specializing in regulatory-compliant AI for clinical research with expertise in FDA guidelines and Good Clinical Practice (GCP).

### Project-Specific Knowledge Areas
- **Clinical Research**: Protocol design, inclusion/exclusion criteria, patient stratification
- **Regulatory AI**: FDA AI/ML guidance, 21 CFR Part 11, clinical trial regulations
- **Medical Ontologies**: SNOMED-CT, ICD-10/11, LOINC, RxNorm, clinical trial terminologies
- **Knowledge Graphs**: Medical knowledge representation, ontology reasoning, semantic matching
- **NLP for Clinical Research**: Protocol parsing, criteria extraction, patient record analysis
- **Ethical AI**: Bias mitigation, fairness in patient selection, informed consent considerations

### Code Generation Focus

#### Clinical Trial Protocol Parser
```python
# Generate advanced clinical trial protocol parser with medical NLP
import re
import spacy
from typing import Dict, List, Tuple, Any, Optional, Set
from dataclasses import dataclass
from enum import Enum
import pandas as pd
from transformers import AutoTokenizer, AutoModel
import torch
import networkx as nx

class CriteriaType(Enum):
    INCLUSION = "inclusion"
    EXCLUSION = "exclusion"

@dataclass
class ClinicalCriterion:
    criterion_id: str
    text: str
    criterion_type: CriteriaType
    category: str  # demographic, medical_history, laboratory, medication, etc.
    severity: str  # must_have, preferred, nice_to_have
    medical_concepts: List[str]
    temporal_constraints: Optional[Dict[str, Any]] = None
    numeric_constraints: Optional[Dict[str, Any]] = None
    logic_operators: Optional[List[str]] = None

class ClinicalTrialProtocolParser:
    def __init__(
        self,
        clinical_bert_model: str = "emilyalsentzer/Bio_ClinicalBERT",
        medical_ner_model: str = "d4data/biomedical-ner-all"
    ):
        """Initialize clinical trial protocol parser with medical NLP."""
        
        # Load medical NLP models
        self.clinical_tokenizer = AutoTokenizer.from_pretrained(clinical_bert_model)
        self.clinical_model = AutoModel.from_pretrained(clinical_bert_model)
        
        # Medical NER
        self.nlp = spacy.load("en_core_sci_sm")  # ScispaCy for medical text
        
        # Medical concept vocabularies
        self.medical_vocabularies = {
            'conditions': self._load_condition_vocabulary(),
            'medications': self._load_medication_vocabulary(),
            'procedures': self._load_procedure_vocabulary(),
            'laboratory': self._load_laboratory_vocabulary()
        }
        
        # Criterion parsing patterns
        self.inclusion_patterns = [
            r'inclusion criteria:?(.+?)(?=exclusion criteria|$)',
            r'patients? must have:?(.+?)(?=exclusion|patients? must not|$)',
            r'eligible patients?:?(.+?)(?=ineligible|exclusion|$)'
        ]
        
        self.exclusion_patterns = [
            r'exclusion criteria:?(.+?)(?=inclusion criteria|$)',
            r'patients? must not have:?(.+?)(?=inclusion|patients? must have|$)',
            r'ineligible patients?:?(.+?)(?=eligible|inclusion|$)'
        ]
        
        # Temporal extraction patterns
        self.temporal_patterns = {
            'within': r'within (\d+)\s*(days?|weeks?|months?|years?)',
            'before': r'(?:prior to|before|at least)\s*(\d+)\s*(days?|weeks?|months?|years?)',
            'after': r'(?:after|following)\s*(\d+)\s*(days?|weeks?|months?|years?)',
            'duration': r'for (?:at least )?(\d+)\s*(days?|weeks?|months?|years?)',
            'age_range': r'(?:age|aged?)\s*(?:between\s*)?(\d+)(?:\s*-\s*|\s*to\s*)(\d+)\s*years?'
        }
        
        # Numeric constraint patterns
        self.numeric_patterns = {
            'greater_than': r'(?:>|greater than|more than|above)\s*([0-9.]+)',
            'less_than': r'(?:<|less than|below|under)\s*([0-9.]+)',
            'equal_to': r'(?:=|equal to|exactly)\s*([0-9.]+)',
            'range': r'(?:between\s*)?([0-9.]+)(?:\s*-\s*|\s*to\s*)([0-9.]+)',
            'at_least': r'at least\s*([0-9.]+)',
            'at_most': r'at most\s*([0-9.]+)'
        }
    
    def _load_condition_vocabulary(self) -> Set[str]:
        """Load medical condition vocabulary."""
        # In practice, load from SNOMED-CT or ICD-10
        return {
            'diabetes', 'hypertension', 'cancer', 'heart failure',
            'copd', 'asthma', 'depression', 'anxiety', 'stroke'
            # Expand with comprehensive medical ontology
        }
    
    def _load_medication_vocabulary(self) -> Set[str]:
        """Load medication vocabulary."""
        # In practice, load from RxNorm
        return {
            'metformin', 'insulin', 'lisinopril', 'amlodipine',
            'atorvastatin', 'warfarin', 'aspirin', 'prednisone'
            # Expand with comprehensive drug ontology
        }
    
    def _load_procedure_vocabulary(self) -> Set[str]:
        """Load medical procedure vocabulary."""
        # In practice, load from CPT or ICD-10-PCS
        return {
            'surgery', 'biopsy', 'catheterization', 'endoscopy',
            'mri', 'ct scan', 'echocardiogram', 'colonoscopy'
            # Expand with comprehensive procedure ontology
        }
    
    def _load_laboratory_vocabulary(self) -> Set[str]:
        """Load laboratory test vocabulary."""
        # In practice, load from LOINC
        return {
            'hemoglobin', 'creatinine', 'glucose', 'cholesterol',
            'triglycerides', 'hemoglobin a1c', 'psa', 'cea'
            # Expand with comprehensive lab test ontology
        }
    
    def extract_criteria_sections(self, protocol_text: str) -> Dict[str, List[str]]:
        """Extract inclusion and exclusion criteria sections."""
        protocol_text = protocol_text.lower()
        
        criteria_sections = {
            'inclusion': [],
            'exclusion': []
        }
        
        # Extract inclusion criteria
        for pattern in self.inclusion_patterns:
            matches = re.findall(pattern, protocol_text, re.IGNORECASE | re.DOTALL)
            criteria_sections['inclusion'].extend(matches)
        
        # Extract exclusion criteria
        for pattern in self.exclusion_patterns:
            matches = re.findall(pattern, protocol_text, re.IGNORECASE | re.DOTALL)
            criteria_sections['exclusion'].extend(matches)
        
        return criteria_sections
    
    def parse_individual_criteria(self, criteria_text: str, criterion_type: CriteriaType) -> List[ClinicalCriterion]:
        """Parse individual criteria from text."""
        
        # Split criteria by numbering or bullet points
        criteria_items = self._split_criteria_items(criteria_text)
        
        parsed_criteria = []
        
        for i, item in enumerate(criteria_items):
            if not item.strip():
                continue
            
            criterion_id = f"{criterion_type.value}_{i+1}"
            
            # Extract medical concepts
            medical_concepts = self._extract_medical_concepts(item)
            
            # Determine category
            category = self._determine_criterion_category(item, medical_concepts)
            
            # Determine severity
            severity = self._determine_criterion_severity(item)
            
            # Extract temporal constraints
            temporal_constraints = self._extract_temporal_constraints(item)
            
            # Extract numeric constraints
            numeric_constraints = self._extract_numeric_constraints(item)
            
            # Extract logic operators
            logic_operators = self._extract_logic_operators(item)
            
            criterion = ClinicalCriterion(
                criterion_id=criterion_id,
                text=item.strip(),
                criterion_type=criterion_type,
                category=category,
                severity=severity,
                medical_concepts=medical_concepts,
                temporal_constraints=temporal_constraints,
                numeric_constraints=numeric_constraints,
                logic_operators=logic_operators
            )
            
            parsed_criteria.append(criterion)
        
        return parsed_criteria
    
    def _split_criteria_items(self, text: str) -> List[str]:
        """Split criteria text into individual items."""
        # Handle various numbering/bullet formats
        patterns = [
            r'\n\s*\d+\.?\s*',  # Numbered list
            r'\n\s*[a-z]\.?\s*',  # Lettered list
            r'\n\s*[-â€¢]\s*',  # Bullet points
            r'\n\s*\*\s*',  # Asterisk bullets
            r';\s*',  # Semicolon separated
            r'\.\s*(?=[A-Z])'  # Sentence breaks
        ]
        
        for pattern in patterns:
            items = re.split(pattern, text)
            if len(items) > 1:
                return [item.strip() for item in items if item.strip()]
        
        # Fallback: return as single item
        return [text.strip()]
    
    def _extract_medical_concepts(self, text: str) -> List[str]:
        """Extract medical concepts using NER and vocabulary matching."""
        doc = self.nlp(text)
        
        concepts = []
        
        # Extract named entities
        for ent in doc.ents:
            if ent.label_ in ['DISEASE', 'DRUG', 'PROCEDURE', 'TEST']:
                concepts.append(ent.text.lower())
        
        # Vocabulary matching
        text_lower = text.lower()
        for vocab_type, vocab in self.medical_vocabularies.items():
            for concept in vocab:
                if concept in text_lower:
                    concepts.append(concept)
        
        return list(set(concepts))
    
    def _determine_criterion_category(
        self, 
        text: str, 
        medical_concepts: List[str]
    ) -> str:
        """Determine the category of a criterion."""
        
        text_lower = text.lower()
        
        # Demographic indicators
        demographic_keywords = ['age', 'gender', 'sex', 'race', 'ethnicity', 'male', 'female']
        if any(keyword in text_lower for keyword in demographic_keywords):
            return 'demographic'
        
        # Laboratory indicators
        lab_keywords = ['lab', 'blood', 'serum', 'plasma', 'urine', 'level', 'count']
        if any(keyword in text_lower for keyword in lab_keywords):
            return 'laboratory'
        
        # Medication indicators
        med_keywords = ['medication', 'drug', 'treatment', 'therapy', 'dose']
        if any(keyword in text_lower for keyword in med_keywords):
            return 'medication'
        
        # Procedure indicators
        proc_keywords = ['surgery', 'procedure', 'operation', 'biopsy', 'scan']
        if any(keyword in text_lower for keyword in proc_keywords):
            return 'procedure'
        
        # Medical history indicators
        history_keywords = ['history', 'previous', 'prior', 'past', 'diagnosed']
        if any(keyword in text_lower for keyword in history_keywords):
            return 'medical_history'
        
        # Performance status
        performance_keywords = ['performance', 'ecog', 'karnofsky', 'functional']
        if any(keyword in text_lower for keyword in performance_keywords):
            return 'performance_status'
        
        # Default based on medical concepts
        if any(concept in self.medical_vocabularies['conditions'] for concept in medical_concepts):
            return 'medical_condition'
        
        return 'other'
    
    def _determine_criterion_severity(self, text: str) -> str:
        """Determine the severity/importance of a criterion."""
        text_lower = text.lower()
        
        # Must-have indicators
        must_have_keywords = ['must', 'required', 'mandatory', 'essential', 'necessary']
        if any(keyword in text_lower for keyword in must_have_keywords):
            return 'must_have'
        
        # Preferred indicators
        preferred_keywords = ['preferred', 'desirable', 'should']
        if any(keyword in text_lower for keyword in preferred_keywords):
            return 'preferred'
        
        return 'must_have'  # Default for clinical trials
    
    def _extract_temporal_constraints(self, text: str) -> Optional[Dict[str, Any]]:
        """Extract temporal constraints from criterion text."""
        constraints = {}
        
        for constraint_type, pattern in self.temporal_patterns.items():
            matches = re.findall(pattern, text, re.IGNORECASE)
            if matches:
                if constraint_type == 'age_range':
                    constraints['age_range'] = {
                        'min_age': int(matches[0][0]),
                        'max_age': int(matches[0][1]),
                        'unit': 'years'
                    }
                else:
                    for match in matches:
                        if isinstance(match, tuple):
                            value, unit = match
                        else:
                            value = match
                            unit = 'days'  # default
                        
                        constraints[constraint_type] = {
                            'value': int(value),
                            'unit': unit.rstrip('s')  # Remove plural
                        }
        
        return constraints if constraints else None
    
    def _extract_numeric_constraints(self, text: str) -> Optional[Dict[str, Any]]:
        """Extract numeric constraints from criterion text."""
        constraints = {}
        
        for constraint_type, pattern in self.numeric_patterns.items():
            matches = re.findall(pattern, text, re.IGNORECASE)
            if matches:
                if constraint_type == 'range':
                    for match in matches:
                        constraints['range'] = {
                            'min_value': float(match[0]),
                            'max_value': float(match[1])
                        }
                else:
                    for match in matches:
                        constraints[constraint_type] = {'value': float(match)}
        
        return constraints if constraints else None
    
    def _extract_logic_operators(self, text: str) -> List[str]:
        """Extract logical operators from criterion text."""
        operators = []
        text_lower = text.lower()
        
        logic_patterns = {
            'and': r'\band\b',
            'or': r'\bor\b',
            'not': r'\bnot\b|\bno\b',
            'except': r'\bexcept\b|\bunless\b'
        }
        
        for operator, pattern in logic_patterns.items():
            if re.search(pattern, text_lower):
                operators.append(operator)
        
        return operators
    
    def parse_protocol(self, protocol_text: str) -> Dict[str, Any]:
        """Parse complete clinical trial protocol."""
        
        # Extract basic protocol information
        protocol_info = self._extract_protocol_metadata(protocol_text)
        
        # Extract criteria sections
        criteria_sections = self.extract_criteria_sections(protocol_text)
        
        # Parse individual criteria
        inclusion_criteria = []
        for section in criteria_sections['inclusion']:
            inclusion_criteria.extend(
                self.parse_individual_criteria(section, CriteriaType.INCLUSION)
            )
        
        exclusion_criteria = []
        for section in criteria_sections['exclusion']:
            exclusion_criteria.extend(
                self.parse_individual_criteria(section, CriteriaType.EXCLUSION)
            )
        
        # Create knowledge graph
        knowledge_graph = self._create_criteria_knowledge_graph(
            inclusion_criteria + exclusion_criteria
        )
        
        return {
            'protocol_info': protocol_info,
            'inclusion_criteria': [criterion.__dict__ for criterion in inclusion_criteria],
            'exclusion_criteria': [criterion.__dict__ for criterion in exclusion_criteria],
            'knowledge_graph': knowledge_graph,
            'parsing_metadata': {
                'total_criteria': len(inclusion_criteria) + len(exclusion_criteria),
                'inclusion_count': len(inclusion_criteria),
                'exclusion_count': len(exclusion_criteria),
                'categories': self._analyze_criteria_categories(inclusion_criteria + exclusion_criteria)
            }
        }
    
    def _extract_protocol_metadata(self, protocol_text: str) -> Dict[str, str]:
        """Extract basic protocol metadata."""
        metadata = {}
        
        # Extract study title
        title_patterns = [
            r'title:?\s*(.+?)(?:\n|$)',
            r'study title:?\s*(.+?)(?:\n|$)'
        ]
        
        for pattern in title_patterns:
            match = re.search(pattern, protocol_text, re.IGNORECASE)
            if match:
                metadata['title'] = match.group(1).strip()
                break
        
        # Extract study phase
        phase_pattern = r'phase\s*(i{1,3}|iv|[1-4])'
        phase_match = re.search(phase_pattern, protocol_text, re.IGNORECASE)
        if phase_match:
            metadata['phase'] = phase_match.group(1).upper()
        
        # Extract condition
        condition_patterns = [
            r'condition:?\s*(.+?)(?:\n|$)',
            r'indication:?\s*(.+?)(?:\n|$)'
        ]
        
        for pattern in condition_patterns:
            match = re.search(pattern, protocol_text, re.IGNORECASE)
            if match:
                metadata['condition'] = match.group(1).strip()
                break
        
        return metadata
    
    def _create_criteria_knowledge_graph(
        self, 
        criteria: List[ClinicalCriterion]
    ) -> Dict[str, Any]:
        """Create knowledge graph from parsed criteria."""
        
        G = nx.DiGraph()
        
        # Add nodes for criteria
        for criterion in criteria:
            G.add_node(
                criterion.criterion_id,
                text=criterion.text,
                type='criterion',
                category=criterion.category,
                severity=criterion.severity
            )
            
            # Add nodes for medical concepts
            for concept in criterion.medical_concepts:
                concept_id = f"concept_{concept.replace(' ', '_')}"
                G.add_node(concept_id, text=concept, type='medical_concept')
                G.add_edge(criterion.criterion_id, concept_id, relation='involves')
        
        # Convert to serializable format
        return {
            'nodes': list(G.nodes(data=True)),
            'edges': list(G.edges(data=True)),
            'node_count': G.number_of_nodes(),
            'edge_count': G.number_of_edges()
        }
    
    def _analyze_criteria_categories(
        self, 
        criteria: List[ClinicalCriterion]
    ) -> Dict[str, int]:
        """Analyze distribution of criteria categories."""
        category_counts = {}
        for criterion in criteria:
            category_counts[criterion.category] = category_counts.get(criterion.category, 0) + 1
        return category_counts
```

#### AI-Powered Patient-Trial Matching Engine
```python
# Generate advanced patient-trial matching with semantic similarity
class PatientTrialMatcher:
    def __init__(
        self,
        clinical_bert_model: str = "emilyalsentzer/Bio_ClinicalBERT",
        similarity_threshold: float = 0.7,
        use_knowledge_graph: bool = True
    ):
        """Initialize patient-trial matching engine."""
        
        # Load clinical BERT for semantic matching
        self.tokenizer = AutoTokenizer.from_pretrained(clinical_bert_model)
        self.model = AutoModel.from_pretrained(clinical_bert_model)
        self.device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
        self.model.to(self.device)
        
        self.similarity_threshold = similarity_threshold
        self.use_knowledge_graph = use_knowledge_graph
        
        # Medical concept mappings
        self.concept_mappings = self._load_concept_mappings()
        
        # Matching rules engine
        self.matching_rules = self._initialize_matching_rules()
    
    def _load_concept_mappings(self) -> Dict[str, Dict[str, List[str]]]:
        """Load medical concept mappings and synonyms."""
        return {
            'conditions': {
                'diabetes': ['diabetes mellitus', 'dm', 'type 1 diabetes', 'type 2 diabetes'],
                'heart_failure': ['congestive heart failure', 'chf', 'cardiac failure'],
                'copd': ['chronic obstructive pulmonary disease', 'emphysema', 'chronic bronchitis']
                # Expand with comprehensive medical ontology mappings
            },
            'medications': {
                'insulin': ['human insulin', 'rapid acting insulin', 'long acting insulin'],
                'metformin': ['glucophage', 'fortamet', 'glumetza']
                # Expand with drug name variations
            }
        }
    
    def _initialize_matching_rules(self) -> Dict[str, Any]:
        """Initialize rule-based matching logic."""
        return {
            'exact_match_weight': 1.0,
            'synonym_match_weight': 0.9,
            'semantic_match_weight': 0.8,
            'category_mismatch_penalty': -0.5,
            'temporal_mismatch_penalty': -0.3,
            'numeric_mismatch_penalty': -0.4
        }
    
    def encode_text(self, text: str) -> torch.Tensor:
        """Encode text using clinical BERT."""
        inputs = self.tokenizer(
            text, 
            return_tensors="pt", 
            truncation=True, 
            padding=True,
            max_length=512
        ).to(self.device)
        
        with torch.no_grad():
            outputs = self.model(**inputs)
            # Use [CLS] token embedding
            embeddings = outputs.last_hidden_state[:, 0, :]
        
        return embeddings.cpu()
    
    def calculate_semantic_similarity(
        self, 
        text1: str, 
        text2: str
    ) -> float:
        """Calculate semantic similarity between two texts."""
        
        embedding1 = self.encode_text(text1)
        embedding2 = self.encode_text(text2)
        
        # Cosine similarity
        similarity = torch.nn.functional.cosine_similarity(
            embedding1, embedding2, dim=-1
        ).item()
        
        return similarity
    
    def match_patient_to_trial(
        self,
        patient_profile: Dict[str, Any],
        trial_criteria: List[ClinicalCriterion],
        detailed_analysis: bool = True
    ) -> Dict[str, Any]:
        """Match a patient to trial criteria with detailed analysis."""
        
        matching_results = {
            'overall_eligibility': None,
            'eligibility_score': 0.0,
            'criterion_matches': [],
            'blocking_exclusions': [],
            'missing_requirements': [],
            'recommendation': '',
            'confidence_score': 0.0
        }
        
        inclusion_score = 0.0
        inclusion_total = 0
        exclusion_violations = []
        
        for criterion in trial_criteria:
            match_result = self._match_single_criterion(
                patient_profile, criterion, detailed_analysis
            )
            
            matching_results['criterion_matches'].append(match_result)
            
            if criterion.criterion_type == CriteriaType.INCLUSION:
                inclusion_total += 1
                if match_result['matches']:
                    inclusion_score += match_result['match_score']
                else:
                    matching_results['missing_requirements'].append({
                        'criterion_id': criterion.criterion_id,
                        'description': criterion.text,
                        'reason': match_result['mismatch_reason']
                    })
            
            elif criterion.criterion_type == CriteriaType.EXCLUSION:
                if match_result['matches']:
                    exclusion_violations.append({
                        'criterion_id': criterion.criterion_id,
                        'description': criterion.text,
                        'match_score': match_result['match_score'],
                        'severity': criterion.severity
                    })
        
        # Calculate overall scores
        inclusion_rate = inclusion_score / inclusion_total if inclusion_total > 0 else 0.0
        
        # Determine eligibility
        has_blocking_exclusions = any(
            violation['severity'] == 'must_have' 
            for violation in exclusion_violations
        )
        
        meets_inclusion_threshold = inclusion_rate >= 0.8  # 80% inclusion criteria
        
        if has_blocking_exclusions:
            matching_results['overall_eligibility'] = False
            matching_results['recommendation'] = "Patient excluded due to exclusion criteria violations"
            matching_results['blocking_exclusions'] = exclusion_violations
        elif meets_inclusion_threshold:
            matching_results['overall_eligibility'] = True
            matching_results['recommendation'] = "Patient appears eligible for trial participation"
        else:
            matching_results['overall_eligibility'] = False
            matching_results['recommendation'] = "Patient does not meet sufficient inclusion criteria"
        
        # Calculate confidence score
        total_criteria = len(trial_criteria)
        clear_matches = sum(1 for match in matching_results['criterion_matches'] 
                           if match['match_score'] > 0.8 or match['match_score'] < 0.2)
        matching_results['confidence_score'] = clear_matches / total_criteria if total_criteria > 0 else 0.0
        
        matching_results['eligibility_score'] = inclusion_rate
        
        return matching_results
    
    def _match_single_criterion(
        self,
        patient_profile: Dict[str, Any],
        criterion: ClinicalCriterion,
        detailed_analysis: bool = True
    ) -> Dict[str, Any]:
        """Match patient against a single criterion."""
        
        match_result = {
            'criterion_id': criterion.criterion_id,
            'criterion_text': criterion.text,
            'criterion_type': criterion.criterion_type.value,
            'category': criterion.category,
            'matches': False,
            'match_score': 0.0,
            'match_method': '',
            'mismatch_reason': '',
            'patient_values': {},
            'extracted_features': []
        }
        
        # Extract relevant patient information based on criterion category
        relevant_patient_data = self._extract_relevant_patient_data(
            patient_profile, criterion
        )
        match_result['patient_values'] = relevant_patient_data
        
        # Apply category-specific matching logic
        if criterion.category == 'demographic':
            match_result = self._match_demographic_criterion(
                relevant_patient_data, criterion, match_result
            )
        elif criterion.category == 'medical_condition':
            match_result = self._match_condition_criterion(
                relevant_patient_data, criterion, match_result
            )
        elif criterion.category == 'laboratory':
            match_result = self._match_laboratory_criterion(
                relevant_patient_data, criterion, match_result
            )
        elif criterion.category == 'medication':
            match_result = self._match_medication_criterion(
                relevant_patient_data, criterion, match_result
            )
        elif criterion.category == 'procedure':
            match_result = self._match_procedure_criterion(
                relevant_patient_data, criterion, match_result
            )
        else:
            # Generic semantic matching
            match_result = self._match_generic_criterion(
                relevant_patient_data, criterion, match_result
            )
        
        return match_result
    
    def _extract_relevant_patient_data(
        self,
        patient_profile: Dict[str, Any],
        criterion: ClinicalCriterion
    ) -> Dict[str, Any]:
        """Extract patient data relevant to specific criterion."""
        
        relevant_data = {}
        
        # Category-based data extraction
        if criterion.category == 'demographic':
            relevant_data.update({
                'age': patient_profile.get('age'),
                'gender': patient_profile.get('gender'),
                'race': patient_profile.get('race'),
                'ethnicity': patient_profile.get('ethnicity')
            })
        
        elif criterion.category == 'medical_condition':
            relevant_data.update({
                'conditions': patient_profile.get('medical_conditions', []),
                'diagnoses': patient_profile.get('diagnoses', []),
                'medical_history': patient_profile.get('medical_history', [])
            })
        
        elif criterion.category == 'laboratory':
            relevant_data.update({
                'lab_results': patient_profile.get('laboratory_results', {}),
                'recent_labs': patient_profile.get('recent_laboratory_results', {})
            })
        
        elif criterion.category == 'medication':
            relevant_data.update({
                'current_medications': patient_profile.get('current_medications', []),
                'medication_history': patient_profile.get('medication_history', [])
            })
        
        elif criterion.category == 'procedure':
            relevant_data.update({
                'procedures': patient_profile.get('procedures', []),
                'surgical_history': patient_profile.get('surgical_history', [])
            })
        
        # Include medical concepts mentioned in criterion
        for concept in criterion.medical_concepts:
            # Search for concept in patient profile
            for key, value in patient_profile.items():
                if isinstance(value, str) and concept.lower() in value.lower():
                    relevant_data[f'concept_match_{concept}'] = value
                elif isinstance(value, list):
                    matches = [item for item in value if concept.lower() in str(item).lower()]
                    if matches:
                        relevant_data[f'concept_matches_{concept}'] = matches
        
        return relevant_data
    
    def _match_demographic_criterion(
        self,
        patient_data: Dict[str, Any],
        criterion: ClinicalCriterion,
        match_result: Dict[str, Any]
    ) -> Dict[str, Any]:
        """Match demographic criteria."""
        
        # Age matching
        if criterion.temporal_constraints and 'age_range' in criterion.temporal_constraints:
            age_constraint = criterion.temporal_constraints['age_range']
            patient_age = patient_data.get('age')
            
            if patient_age is not None:
                if age_constraint['min_age'] <= patient_age <= age_constraint['max_age']:
                    match_result['matches'] = True
                    match_result['match_score'] = 1.0
                    match_result['match_method'] = 'age_range_exact'
                else:
                    match_result['matches'] = False
                    match_result['mismatch_reason'] = f"Age {patient_age} outside range {age_constraint['min_age']}-{age_constraint['max_age']}"
            else:
                match_result['mismatch_reason'] = "Patient age not available"
        
        # Gender matching
        gender_keywords = ['male', 'female', 'man', 'woman']
        criterion_text_lower = criterion.text.lower()
        
        for gender_keyword in gender_keywords:
            if gender_keyword in criterion_text_lower:
                patient_gender = patient_data.get('gender', '').lower()
                if gender_keyword in patient_gender or (gender_keyword == 'man' and 'male' in patient_gender):
                    match_result['matches'] = True
                    match_result['match_score'] = 1.0
                    match_result['match_method'] = 'gender_exact'
                    break
        
        return match_result
    
    def _match_condition_criterion(
        self,
        patient_data: Dict[str, Any],
        criterion: ClinicalCriterion,
        match_result: Dict[str, Any]
    ) -> Dict[str, Any]:
        """Match medical condition criteria."""
        
        patient_conditions = patient_data.get('conditions', []) + patient_data.get('diagnoses', [])
        
        # Check for exact matches in medical concepts
        for concept in criterion.medical_concepts:
            # Direct matching
            for condition in patient_conditions:
                if concept.lower() in condition.lower():
                    match_result['matches'] = True
                    match_result['match_score'] = 1.0
                    match_result['match_method'] = 'condition_exact'
                    return match_result
            
            # Synonym matching
            if concept in self.concept_mappings.get('conditions', {}):
                synonyms = self.concept_mappings['conditions'][concept]
                for condition in patient_conditions:
                    for synonym in synonyms:
                        if synonym.lower() in condition.lower():
                            match_result['matches'] = True
                            match_result['match_score'] = self.matching_rules['synonym_match_weight']
                            match_result['match_method'] = 'condition_synonym'
                            return match_result
        
        # Semantic matching
        if patient_conditions:
            best_similarity = 0.0
            for condition in patient_conditions:
                similarity = self.calculate_semantic_similarity(
                    criterion.text, condition
                )
                best_similarity = max(best_similarity, similarity)
            
            if best_similarity >= self.similarity_threshold:
                match_result['matches'] = True
                match_result['match_score'] = best_similarity * self.matching_rules['semantic_match_weight']
                match_result['match_method'] = 'condition_semantic'
            else:
                match_result['mismatch_reason'] = f"No matching conditions found (best similarity: {best_similarity:.2f})"
        else:
            match_result['mismatch_reason'] = "No medical conditions available for patient"
        
        return match_result
```

### Testing Focus Areas
- Clinical protocol parsing accuracy and completeness
- Patient-trial matching precision and recall
- Regulatory compliance validation (21 CFR Part 11)
- Medical ontology integration and concept mapping
- Bias detection in patient selection algorithms
- Clinical decision support system integration

### Documentation Priorities
- Regulatory compliance documentation (FDA AI/ML guidance)
- Clinical validation studies and performance metrics
- Medical ontology mapping and concept relationships
- Integration specifications for Electronic Health Records
- Quality assurance procedures for clinical research
- Audit trail documentation for regulatory submissions

### Performance Considerations
- Scalable processing for large clinical trial databases
- Real-time patient screening for clinical research coordinators
- Efficient semantic matching with medical concept hierarchies
- Memory optimization for large medical knowledge graphs
- Secure handling of patient health information (HIPAA compliance)

Remember: Focus on creating regulatory-compliant, clinically-validated AI systems that support clinical research while maintaining the highest standards of patient safety, data privacy, and scientific rigor.
